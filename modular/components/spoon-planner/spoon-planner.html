<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SpoonPal Protocol Timeline - Enhanced</title>
    <style>
        body { 
            font-family: Arial, sans-serif; 
            margin: 20px; 
            background: #f5f5f5; 
        }
        .container { 
            max-width: 1200px; 
            margin: 0 auto; 
            background: white; 
            padding: 20px; 
            border-radius: 8px; 
            box-shadow: 0 2px 4px rgba(0,0,0,0.1); 
        }
        .timestamp { 
            font-weight: bold; 
            font-size: 1.1em; 
            margin-bottom: 20px; 
            color: #333; 
        }
        .debt-warning {
            background: #ff6b6b;
            color: white;
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 20px;
            font-weight: bold;
            text-align: center;
            display: none;
        }
        .debt-warning.active { display: block; }
        .spoon-section { 
            background: #e8f4fd; 
            padding: 15px; 
            border-radius: 6px; 
            margin-bottom: 20px; 
        }
        .check-in-section {
            background: #f0f8ff;
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 20px;
        }
        .check-in-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin-top: 10px;
        }
        .check-in-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .check-in-item input, .check-in-item select {
            width: 80px;
            padding: 4px;
            border: 1px solid #ddd;
            border-radius: 3px;
        }
        .legend { 
            background: #fff3cd; 
            padding: 10px; 
            border-radius: 4px; 
            margin-bottom: 15px; 
            font-family: monospace; 
            font-size: 0.9em; 
        }
        .weather-info {
            background: #d4edda;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 15px;
            font-size: 0.9em;
        }
        table { 
            width: 100%; 
            border-collapse: collapse; 
            margin-bottom: 20px; 
        }
        th, td { 
            border: 1px solid #ddd; 
            padding: 8px; 
            text-align: left; 
            font-size: 0.9em; 
        }
        th { 
            background-color: #f8f9fa; 
            font-weight: bold; 
        }
        .editable {
            cursor: pointer;
            background: #f9f9f9;
        }
        .editable:hover {
            background: #e9e9e9;
        }
        .task-management {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 20px;
        }
        .template-section {
            background: #e6f3ff;
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 20px;
        }
        .learning-insights {
            background: #fff0f5;
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 20px;
        }
        .reference-section { 
            background: #f8f9fa; 
            padding: 15px; 
            border-radius: 6px; 
            margin-top: 20px; 
            font-family: monospace; 
            font-size: 0.85em; 
        }
        .nonope-log { 
            background: #ffe6e6; 
            padding: 15px; 
            border-radius: 6px; 
            margin-top: 15px; 
            font-family: monospace; 
            font-size: 0.85em; 
        }
        .archive-section {
            background: #f5f5f5;
            padding: 15px;
            border-radius: 6px;
            margin-top: 20px;
        }
        button { 
            padding: 10px 20px; 
            margin: 5px; 
            border: none; 
            border-radius: 4px; 
            cursor: pointer; 
            font-size: 0.9em; 
        }
        .btn-primary { background: #007bff; color: white; }
        .btn-success { background: #28a745; color: white; }
        .btn-warning { background: #ffc107; color: black; }
        .btn-danger { background: #dc3545; color: white; }
        .btn-info { background: #17a2b8; color: white; }
        .btn-secondary { background: #6c757d; color: white; }
        .controls { margin-bottom: 20px; }
        .controls-row { display: flex; flex-wrap: wrap; gap: 5px; margin-bottom: 10px; }
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.4);
        }
        .modal-content {
            background-color: #fefefe;
            margin: 15% auto;
            padding: 20px;
            border: 1px solid #888;
            width: 80%;
            max-width: 500px;
            border-radius: 6px;
        }
        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }
        .close:hover { color: black; }
        .burnout-advisory {
            background: linear-gradient(45deg, #ffeb3b, #ff9800);
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 20px;
            border-left: 4px solid #f44336;
        }
        .learning-badge {
            background: #4caf50;
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 0.7em;
            margin-left: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div id="timestamp" class="timestamp"></div>
        
        <!-- Spoon Debt Warning System -->
        <div id="debtWarning" class="debt-warning">
            <span id="debtWarningText">üö® SPOON DEBT WARNING üö®</span>
        </div>
        
        <!-- Burnout Advisory (never blocking) -->
        <div id="burnoutAdvisory" class="burnout-advisory" style="display: none;">
            <h4>‚ö†Ô∏è Burnout Advisory (Guidance Only)</h4>
            <p id="burnoutAdvice">Consider reducing non-essential tasks and prioritizing rest.</p>
        </div>

        <!-- Automated Check-in Section -->
        <div class="check-in-section">
            <h3>Daily Check-in (Auto-populated, User Editable)</h3>
            <div class="check-in-grid">
                <div class="check-in-item">
                    <label>Pain Level (1-10):</label>
                    <input type="number" id="painLevel" min="1" max="10" value="5" onchange="saveCheckIn()">
                </div>
                <div class="check-in-item">
                    <label>Fatigue Level (1-10):</label>
                    <input type="number" id="fatigueLevel" min="1" max="10" value="5" onchange="saveCheckIn()">
                </div>
                <div class="check-in-item">
                    <label>Mood:</label>
                    <select id="moodLevel" onchange="saveCheckIn()">
                        <option value="excellent">Excellent</option>
                        <option value="good">Good</option>
                        <option value="okay" selected>Okay</option>
                        <option value="poor">Poor</option>
                        <option value="terrible">Terrible</option>
                    </select>
                </div>
                <div class="check-in-item">
                    <label>Sleep Hours:</label>
                    <input type="number" id="sleepHours" min="0" max="24" step="0.5" value="8" onchange="saveCheckIn()">
                </div>
                <div class="check-in-item">
                    <label>CPAP Usage:</label>
                    <input type="text" id="cpapUsage" value="Auto-detected" onchange="saveCheckIn()">
                </div>
                <div class="check-in-item">
                    <label>House Temp:</label>
                    <input type="number" id="houseTemp" value="68" onchange="saveCheckIn()">¬∞F
                </div>
            </div>
        </div>

        <!-- Weather Integration -->
        <div id="weatherSection" class="weather-info">
            <strong>Weather Impact:</strong> <span id="weatherInfo">Loading...</span>
            <button onclick="refreshWeather()" class="btn-info" style="padding: 2px 8px; font-size: 0.8em; margin-left: 10px;">Refresh</button>
        </div>

        <!-- Spoon Section -->
        <div id="spoonSection" class="spoon-section">
            <h3>Spoon Management</h3>
            <div>Baseline: <span id="baseline">20</span> | Borrowed: <span id="borrowed">0</span> | Start: <span id="start">20</span></div>
            <div>Planned Cost: <span id="planned">0</span> | Spent: <span id="spent">0</span> | Remaining: <span id="remaining">20</span></div>
            <div>Depletion: <span id="depletion">0</span> | Consecutive Debt Days: <span id="consecutiveDebt">0</span></div>
        </div>

        <!-- Learning Insights -->
        <div class="learning-insights">
            <h3>SpoonPal Learning Insights</h3>
            <div id="learningInsights">Analyzing your patterns...</div>
        </div>

        <!-- Enhanced Controls -->
        <div class="controls">
            <div class="controls-row">
                <button class="btn-primary" onclick="generateWeekdayTemplate()">Generate Weekday</button>
                <button class="btn-success" onclick="generateSundayTemplate()">Generate Sunday</button>
                <button class="btn-info" onclick="showTaskManager()">Manage Tasks</button>
                <button class="btn-info" onclick="showTemplateManager()">Templates</button>
                <button class="btn-warning" onclick="autoReschedule()">Auto-Reschedule</button>
            </div>
            <div class="controls-row">
                <button class="btn-secondary" onclick="showArchive()">View Archive</button>
                <button class="btn-secondary" onclick="exportData()">Export Data</button>
                <button class="btn-secondary" onclick="importData()">Import Data</button>
                <button class="btn-danger" onclick="resetDay()">Reset Day</button>
            </div>
        </div>

        <!-- Task Management -->
        <div id="taskManager" class="task-management" style="display: none;">
            <h3>Task Management</h3>
            <button onclick="addNewTask()" class="btn-success">Add New Task</button>
            <button onclick="editSelectedTask()" class="btn-warning">Edit Selected</button>
            <button onclick="archiveSelectedTask()" class="btn-secondary">Archive Selected</button>
            <div id="taskList"></div>
        </div>

        <!-- Template Management -->
        <div id="templateManager" class="template-section" style="display: none;">
            <h3>Template Management</h3>
            <button onclick="saveAsTemplate()" class="btn-success">Save Current as Template</button>
            <button onclick="loadTemplate()" class="btn-info">Load Template</button>
            <div id="templateList"></div>
        </div>

        <!-- Protocol-Locked Legend -->
        <div id="legend" class="legend"></div>
        
        <!-- Timeline Table -->
        <table id="timelineTable">
            <thead>
                <tr>
                    <th>Select</th>
                    <th>Time</th>
                    <th>Lmj</th>
                    <th>Task (Priority)</th>
                    <th>ü•Ñ</th>
                    <th>Status</th>
                    <th>AreaNotes</th>
                    <th>Actions</th>
                </tr>
            </thead>
            <tbody id="timelineBody">
            </tbody>
        </table>

        <!-- Archive Section -->
        <div id="archiveSection" class="archive-section" style="display: none;">
            <h3>Archived Items</h3>
            <div id="archiveList"></div>
            <button onclick="clearArchive()" class="btn-danger">Clear Archive</button>
        </div>

        <div id="referenceSection" class="reference-section"></div>
        <div id="nonopeLog" class="nonope-log"></div>
    </div>

    <!-- Modals -->
    <div id="taskModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal('taskModal')">&times;</span>
            <h2>Edit Task</h2>
            <form id="taskForm">
                <p>Time: <input type="text" id="modalTime" placeholder="0800"></p>
                <p>AM/PM: <select id="modalAmPm"><option>AM</option><option>PM</option></select></p>
                <p>Fixed/Flexible: <select id="modalFixed"><option value="true">Fixed</option><option value="false">Flexible</option></select></p>
                <p>LMJ: <input type="text" id="modalLmj" placeholder="A"></p>
                <p>Emoji: <input type="text" id="modalEmoji" placeholder="üíä"></p>
                <p>Description: <input type="text" id="modalDescription" placeholder="Morning meds"></p>
                <p>Priority: <select id="modalPriority"><option>High</option><option>Medium</option><option>Low</option></select></p>
                <p>Spoon Cost: <input type="number" id="modalSpoonCost" min="0" max="10" step="0.5"></p>
                <p>Area Notes: <input type="text" id="modalNotes" placeholder="Area notes"></p>
                <button type="button" onclick="saveTask()">Save Task</button>
                <button type="button" onclick="closeModal('taskModal')">Cancel</button>
            </form>
        </div>
    </div>

    <script>
        // ===== PROTOCOL-LOCKED DATA =====
        
        // LMJ Order from attached file - NEVER CHANGE
        const LOCKED_LMJ_ORDER = [
            { lmj: 'A', emoji: 'üíä', description: 'Morning meds' },
            { lmj: 'V', emoji: 'ü¶æ', description: 'CPAP prep, wrist brace' },
            { lmj: 'B', emoji: 'üçΩÔ∏è', description: 'Family scriptures, breakfast' },
            { lmj: 'G', emoji: 'üê•', description: 'Gosling time' },
            { lmj: 'N', emoji: 'üì∞', description: 'News with Mom' },
            { lmj: 'ME', emoji: 'üßò', description: 'Me time' },
            { lmj: 'H', emoji: 'üß∫', description: 'Hamper/laundry (change clothes, hamper, bathroom)' },
            { lmj: 'CC', emoji: 'üõèÔ∏è', description: 'In bed' },
            { lmj: 'DD', emoji: 'üí®', description: 'Breathe, recover' },
            { lmj: 'EE', emoji: 'üò∑', description: 'CPAP mask on' },
            { lmj: 'FF', emoji: 'ü§ö', description: 'Wrist brace on' },
            { lmj: 'ZZ', emoji: 'üìµ', description: 'Device off, crash' }
        ];

        // Status Icons - ‚è≠Ô∏è IS EXPRESSLY FORBIDDEN
        const STATUS_ICONS = {
            complete: '‚úÖ',
            incomplete: '‚¨ú',
            partial: '‚è≥',
            progress: 'üõ†Ô∏è',
            interrupted: 'üöß', 
            skipped: '‚ùå',  // NOT ‚è≠Ô∏è which is FORBIDDEN
            rescheduled: 'üîÑ'
        };

        // Bathroom Break Emojis Pool
        const BB_EMOJIS = ['üöΩ', 'üöª', 'üöæ', 'üöΩüí®', 'üöΩüßª', 'üßªüöΩ', 'üöø', 'üõÅ'];

        // Protocol-Locked Legend
        const LEGEND = "Fixed üîí Flexible ‚ÜïÔ∏è Urgent üî• AM ‚òÄÔ∏è PM üåô ü•Ñ Spoon Lmj üéØ Status ‚úÖ Complete ‚¨ú Incomplete ‚è≥ Partial üõ†Ô∏è Progress üöß Interrupted ‚ùå Skipped üîÑ Rescheduled";

        // ===== GLOBAL STATE =====
        
        let timelineData = [];
        let archiveData = [];
        let templates = {};
        let checkInData = {};
        let spoonHistory = [];
        let selectedTaskIndex = null;
        let bbEmojiUsed = [];
        let learningData = {};

        // ===== INITIALIZATION =====
        
        function init() {
            loadAllData();
            updateTimestamp();
            updateWeather();
            autoFillCheckIn();
            updateDebtWarning();
            updateBurnoutAdvisory();
            updateLegend();
            calculateSpoons();
            renderTimeline();
            updateLearningInsights();
            updateReferenceSection();
            updateNonopeLog();
            setInterval(updateTimestamp, 60000);
            setInterval(autoSave, 30000); // Auto-save every 30 seconds
        }

        // ===== PERSISTENCE FUNCTIONS =====
        
        function saveAllData() {
            const saveData = {
                timelineData,
                archiveData,
                templates,
                checkInData,
                spoonHistory,
                bbEmojiUsed,
                learningData,
                lastSave: new Date().toISOString()
            };
            localStorage.setItem('spoonPalData', JSON.stringify(saveData));
        }

        function loadAllData() {
            const saved = localStorage.getItem('spoonPalData');
            if (saved) {
                const data = JSON.parse(saved);
                timelineData = data.timelineData || [];
                archiveData = data.archiveData || [];
                templates = data.templates || {};
                checkInData = data.checkInData || {};
                spoonHistory = data.spoonHistory || [];
                bbEmojiUsed = data.bbEmojiUsed || [];
                learningData = data.learningData || {};
            }
        }

        function autoSave() {
            saveAllData();
            console.log('Auto-saved at', new Date().toLocaleTimeString());
        }

        // ===== CHECK-IN AUTOMATION =====
        
        function autoFillCheckIn() {
            // Auto-populate based on recent patterns and device data
            const today = new Date().toDateString();
            
            if (!checkInData[today]) {
                checkInData[today] = {
                    painLevel: getPredictedPain(),
                    fatigueLevel: getPredictedFatigue(),
                    mood: 'okay',
                    sleepHours: getLastNightSleep(),
                    cpapUsage: 'Auto-detected',
                    houseTemp: 68
                };
            }

            // Update UI
            document.getElementById('painLevel').value = checkInData[today].painLevel;
            document.getElementById('fatigueLevel').value = checkInData[today].fatigueLevel;
            document.getElementById('moodLevel').value = checkInData[today].mood;
            document.getElementById('sleepHours').value = checkInData[today].sleepHours;
            document.getElementById('cpapUsage').value = checkInData[today].cpapUsage;
            document.getElementById('houseTemp').value = checkInData[today].houseTemp;
        }

        function saveCheckIn() {
            const today = new Date().toDateString();
            checkInData[today] = {
                painLevel: parseInt(document.getElementById('painLevel').value),
                fatigueLevel: parseInt(document.getElementById('fatigueLevel').value),
                mood: document.getElementById('moodLevel').value,
                sleepHours: parseFloat(document.getElementById('sleepHours').value),
                cpapUsage: document.getElementById('cpapUsage').value,
                houseTemp: parseInt(document.getElementById('houseTemp').value)
            };
            
            // Recalculate spoons based on check-in
            adjustBaseline();
            calculateSpoons();
            updateDebtWarning();
            updateBurnoutAdvisory();
            saveAllData();
        }

        // ===== SPOON DEBT WARNING SYSTEM =====
        
        function updateDebtWarning() {
            const consecutiveDays = getConsecutiveDebtDays();
            const warningEl = document.getElementById('debtWarning');
            const textEl = document.getElementById('debtWarningText');
            
            document.getElementById('consecutiveDebt').textContent = consecutiveDays;
            
            if (consecutiveDays >= 2) {
                warningEl.classList.add('active');
                if (consecutiveDays === 2) {
                    textEl.textContent = 'üö® SPOON DEBT WARNING üö® Day 2 of consecutive debt';
                } else if (consecutiveDays === 3) {
                    textEl.textContent = '‚ö†Ô∏è BURNOUT RISK ZONE ‚ö†Ô∏è Day 3 in debt - entering burnout risk';
                } else if (consecutiveDays >= 5) {
                    textEl.textContent = 'üÜò CRITICAL DEBT PERIOD üÜò Day ' + consecutiveDays + ' - medical crisis territory';
                } else {
                    textEl.textContent = 'üö® EXTENDED DEBT üö® Day ' + consecutiveDays + ' of consecutive spoon debt';
                }
            } else {
                warningEl.classList.remove('active');
            }
        }

        function getConsecutiveDebtDays() {
            if (spoonHistory.length === 0) return 0;
            
            let consecutiveDays = 0;
            for (let i = spoonHistory.length - 1; i >= 0; i--) {
                if (spoonHistory[i].endBalance < 0) {
                    consecutiveDays++;
                } else {
                    break;
                }
            }
            return consecutiveDays;
        }

        // ===== BURNOUT ADVISORY (NON-BLOCKING) =====
        
        function updateBurnoutAdvisory() {
            const advisoryEl = document.getElementById('burnoutAdvisory');
            const adviceEl = document.getElementById('burnoutAdvice');
            
            const consecutiveDays = getConsecutiveDebtDays();
            const currentPain = parseInt(document.getElementById('painLevel').value);
            const currentFatigue = parseInt(document.getElementById('fatigueLevel').value);
            
            if (consecutiveDays >= 3 || currentPain >= 8 || currentFatigue >= 8) {
                advisoryEl.style.display = 'block';
                
                let advice = 'Consider reducing non-essential tasks and prioritizing rest. ';
                if (consecutiveDays >= 3) advice += 'Multiple days of spoon debt detected. ';
                if (currentPain >= 8) advice += 'High pain level - extra rest recommended. ';
                if (currentFatigue >= 8) advice += 'High fatigue - limit demanding activities. ';
                advice += 'This is guidance only - you control all scheduling decisions.';
                
                adviceEl.textContent = advice;
            } else {
                advisoryEl.style.display = 'none';
            }
        }

        // ===== WEATHER INTEGRATION =====
        
        function updateWeather() {
            // Simulate weather API call - replace with real API
            setTimeout(() => {
                const weather = generateMockWeather();
                document.getElementById('weatherInfo').textContent = weather.description;
                
                // Adjust spoons based on weather
                adjustForWeather(weather);
            }, 1000);
        }

        function refreshWeather() {
            document.getElementById('weatherInfo').textContent = 'Updating...';
            updateWeather();
        }

        function generateMockWeather() {
            const conditions = [
                { temp: 75, condition: 'sunny', spoonImpact: 0, description: '75¬∞F Sunny - Ideal conditions, no spoon penalty' },
                { temp: 60, condition: 'cold', spoonImpact: -3, description: '60¬∞F Cold - Reduces available spoons by 3' },
                { temp: 85, condition: 'hot', spoonImpact: -1, description: '85¬∞F Hot - Slight spoon reduction, stay hydrated' }
            ];
            return conditions[Math.floor(Math.random() * conditions.length)];
        }

        // ===== AUTO-RESCHEDULING =====
        
        function autoReschedule() {
            const now = new Date();
            const currentTime = now.getHours() * 100 + now.getMinutes();
            
            timelineData.forEach((task, index) => {
                if (task.status === 'incomplete' && (task.priority === 'High' || task.priority === 'Urgent')) {
                    const taskTime = parseInt(task.time);
                    if (taskTime < currentTime && !task.fixed) {
                        // Find next available slot
                        const nextSlot = findNextAvailableSlot(currentTime);
                        if (nextSlot) {
                            task.time = nextSlot.time;
                            task.ampm = nextSlot.ampm;
                            task.status = 'rescheduled';
                            
                            // Learning: track rescheduling patterns
                            trackLearningEvent('reschedule', {
                                taskType: task.lmj,
                                originalTime: taskTime,
                                newTime: nextSlot.time,
                                reason: 'auto_reschedule_high_priority'
                            });
                        }
                    }
                }
            });
            
            renderTimeline();
            saveAllData();
            alert('Auto-rescheduling completed for high-priority incomplete tasks.');
        }

        function findNextAvailableSlot(afterTime) {
            // Simple logic - find next 30-minute increment
            let nextTime = Math.ceil(afterTime / 50) * 50;
            if (nextTime >= 2400) {
                nextTime = 100; // Next day
                return { time: nextTime.toString().padStart(4, '0'), ampm: 'AM' };
            }
            
            const ampm = nextTime >= 1200 ? 'PM' : 'AM';
            const displayTime = nextTime > 1200 ? (nextTime - 1200).toString().padStart(4, '0') : nextTime.toString().padStart(4, '0');
            
            return { time: displayTime, ampm: ampm };
        }

        // ===== LEARNING SYSTEM =====
        
        function trackLearningEvent(eventType, data) {
            if (!learningData[eventType]) {
                learningData[eventType] = [];
            }
            learningData[eventType].push({
                timestamp: new Date().toISOString(),
                data: data
            });
        }

        function updateLearningInsights() {
            const insights = generateLearningInsights();
            document.getElementById('learningInsights').innerHTML = insights;
        }

        function generateLearningInsights() {
            let insights = '';
            
            // Analyze completion patterns
            const completedTasks = timelineData.filter(t => t.status === 'complete');
            if (completedTasks.length > 0) {
                insights += `<span class="learning-badge">LEARNED</span> You've completed ${completedTasks.length} tasks today. `;
            }
            
            // Analyze spoon accuracy
            if (learningData.spoon_adjustments && learningData.spoon_adjustments.length > 5) {
                insights += `<span class="learning-badge">ADAPTING</span> Adjusting spoon estimates based on your patterns. `;
            }
            
            // Analyze timing patterns
            const morningTasks = timelineData.filter(t => t.ampm === 'AM' && t.status === 'complete');
            if (morningTasks.length >= 3) {
                insights += `<span class="learning-badge">PATTERN</span> You're most productive in the morning. `;
            }
            
            if (!insights) {
                insights = 'Building learning profile... Complete more tasks to see insights.';
            }
            
            return insights;
        }

        // ===== PREDICTION HELPERS =====
        
        function getPredictedPain() {
            const recent = Object.values(checkInData).slice(-7); // Last 7 days
            if (recent.length === 0) return 5;
            const avg = recent.reduce((sum, day) => sum + day.painLevel, 0) / recent.length;
            return Math.round(avg);
        }

        function getPredictedFatigue() {
            const recent = Object.values(checkInData).slice(-7);
            if (recent.length === 0) return 5;
            const avg = recent.reduce((sum, day) => sum + day.fatigueLevel, 0) / recent.length;
            return Math.round(avg);
        }

        function getLastNightSleep() {
            const recent = Object.values(checkInData).slice(-1)[0];
            return recent ? recent.sleepHours : 8;
        }

        // ===== SPOON CALCULATIONS =====
        
        function adjustBaseline() {
            let baseline = 20;
            const pain = parseInt(document.getElementById('painLevel').value);
            const fatigue = parseInt(document.getElementById('fatigueLevel').value);
            const sleep = parseFloat(document.getElementById('sleepHours').value);
            const temp = parseInt(document.getElementById('houseTemp').value);
            
            // Adjust for pain (higher pain = fewer spoons)
            baseline -= Math.max(0, (pain - 5));
            
            // Adjust for fatigue
            baseline -= Math.max(0, (fatigue - 5));
            
            // Adjust for sleep (less than 7 hours = penalty)
            if (sleep < 7) {
                baseline -= (7 - sleep) * 2;
            }
            
            // Adjust for temperature (below 70¬∞F = penalty)
            if (temp < 70) {
                baseline -= Math.floor((70 - temp) / 5);
            }
            
            baseline = Math.max(1, baseline); // Never go below 1
            document.getElementById('baseline').textContent = baseline;
        }

        function calculateSpoons() {
            const baseline = parseInt(document.getElementById('baseline').textContent);
            const borrowed = parseInt(document.getElementById('borrowed').textContent);
            const start = baseline - borrowed;
            const planned = timelineData.reduce((sum, task) => sum + task.spoonCost, 0);
            const spent = timelineData.filter(task => 
                task.status === 'complete' || task.status === 'partial'
            ).reduce((sum, task) => sum + (task.status === 'partial' ? task.spoonCost * 0.5 : task.spoonCost), 0);
            const remaining = start - spent;
            const depletion = remaining - (planned - spent);

            document.getElementById('start').textContent = start;
            document.getElementById('planned').textContent = planned;
            document.getElementById('spent').textContent = spent.toFixed(1);
            document.getElementById('remaining').textContent = remaining.toFixed(1);
            document.getElementById('depletion').textContent = depletion.toFixed(1);
            
            // Store daily spoon data
            const today = new Date().toDateString();
            spoonHistory = spoonHistory.filter(entry => entry.date !== today);
            spoonHistory.push({
                date: today,
                baseline: baseline,
                borrowed: borrowed,
                spent: spent,
                endBalance: remaining
            });
        }

        // ===== TEMPLATE SYSTEM =====
        
        function saveAsTemplate() {
            const name = prompt("Template name:");
            if (name && timelineData.length > 0) {
                templates[name] = JSON.deepCopy(timelineData);
                updateTemplateList();
                saveAllData();
                alert("Template saved successfully!");
            }
        }

        function loadTemplate() {
            const name = prompt("Template name to load:");
            if (name && templates[name]) {
                timelineData = JSON.deepCopy(templates[name]);
                resetBBEmojis();
                renderTimeline();
                calculateSpoons();
                saveAllData();
            } else {
                alert("Template not found!");
            }
        }

        function updateTemplateList() {
            const list = document.getElementById('templateList');
            list.innerHTML = '';
            Object.keys(templates).forEach(name => {
                const item = document.createElement('div');
                item.innerHTML = `
                    <span>${name}</span>
                    <button onclick="loadTemplate('${name}')" class="btn-info">Load</button>
                    <button onclick="deleteTemplate('${name}')" class="btn-danger">Delete</button>
                `;
                list.appendChild(item);
            });
        }

        // ===== TIMELINE MANAGEMENT =====
        
        function generateWeekdayTemplate() {
            timelineData = LOCKED_LMJ_ORDER.map((lmj, index) => {
                const baseTime = 700 + (index * 100);
                let displayTime = baseTime;
                let ampm = 'AM';
                
                if (displayTime >= 1200) {
                    ampm = 'PM';
                    if (displayTime > 1200) {
                        displayTime = displayTime - 1200;
                    }
                }
                
                return {
                    time: displayTime.toString().padStart(4, '0'),
                    ampm: ampm,
                    fixed: ['A', 'V', 'CC', 'DD', 'EE', 'FF', 'ZZ'].includes(lmj.lmj),
                    lmj: lmj.lmj,
                    emoji: lmj.emoji,
                    description: lmj.description + ' (High)',
                    spoonCost: lmj.lmj === 'A' || lmj.lmj === 'B' ? 2 : 1,
                    status: 'incomplete',
                    notes: 'Generated from template'
                };
            });
            
            resetBBEmojis();
            calculateSpoons();
            renderTimeline();
            saveAllData();
        }

        function generateSundayTemplate() {
            // Sunday: Only essential and explicitly allowed tasks
            timelineData = [
                { time: '0730', ampm: 'AM', fixed: true, lmj: 'A', emoji: 'üíä', description: 'Morning meds (High)', spoonCost: 2, status: 'incomplete', notes: 'Essential' },
                { time: '1130', ampm: 'AM', fixed: true, lmj: 'CH', emoji: '‚õ™', description: 'Church service (Highest)', spoonCost: 3, status: 'incomplete', notes: 'Fixed slot' },
                { time: '0600', ampm: 'PM', fixed: false, lmj: 'N', emoji: 'üì∞', description: 'News with Mom (High)', spoonCost: 1, status: 'incomplete', notes: 'Evening routine' },
                { time: '0900', ampm: 'PM', fixed: true, lmj: 'CC', emoji: 'üõèÔ∏è', description: 'In bed (High)', spoonCost: 0, status: 'incomplete', notes: 'Rest' },
                { time: '1000', ampm: 'PM', fixed: true, lmj: 'ZZ', emoji: 'üìµ', description: 'Device off, crash (High)', spoonCost: 0, status: 'incomplete', notes: 'Sleep' }
            ];
            
            resetBBEmojis();
            calculateSpoons();
            renderTimeline();
            saveAllData();
        }

        function renderTimeline() {
            const tbody = document.getElementById('timelineBody');
            tbody.innerHTML = '';

            // Validate LMJ order
            validateLMJOrder();
            
            timelineData.forEach((task, index) => {
                const row = document.createElement('tr');
                
                // Selection checkbox
                const selectCell = document.createElement('td');
                selectCell.innerHTML = `<input type="checkbox" onchange="selectTask(${index})">`;
                row.appendChild(selectCell);
                
                // Time with icons
                const timeCell = document.createElement('td');
                const timeIcon = task.ampm === 'AM' ? '‚òÄÔ∏è' : 'üåô';
                const flexIcon = task.fixed ? 'üîí' : '‚ÜïÔ∏è';
                timeCell.innerHTML = `${task.time} ${timeIcon} ${flexIcon}`;
                row.appendChild(timeCell);

                // LMJ with emoji
                const lmjCell = document.createElement('td');
                lmjCell.innerHTML = `${task.lmj}${task.emoji}`;
                row.appendChild(lmjCell);

                // Task description (editable)
                const taskCell = document.createElement('td');
                taskCell.innerHTML = task.description;
                taskCell.className = 'editable';
                taskCell.onclick = () => editTask(index);
                row.appendChild(taskCell);

                // Spoon cost (editable)
                const spoonCell = document.createElement('td');
                spoonCell.innerHTML = task.spoonCost;
                spoonCell.className = 'editable';
                spoonCell.onclick = () => editSpoonCost(index);
                row.appendChild(spoonCell);

                // Status (clickable)
                const statusCell = document.createElement('td');
                statusCell.innerHTML = STATUS_ICONS[task.status];
                statusCell.style.cursor = 'pointer';
                statusCell.onclick = () => toggleStatus(index);
                row.appendChild(statusCell);

                // Area notes (editable)
                const notesCell = document.createElement('td');
                notesCell.innerHTML = task.notes;
                notesCell.className = 'editable';
                notesCell.onclick = () => editNotes(index);
                row.appendChild(notesCell);

                // Actions
                const actionsCell = document.createElement('td');
                actionsCell.innerHTML = `
                    <button onclick="editTask(${index})" class="btn-warning" style="padding: 2px 6px; font-size: 0.7em;">Edit</button>
                    <button onclick="archiveTask(${index})" class="btn-secondary" style="padding: 2px 6px; font-size: 0.7em;">Archive</button>
                `;
                row.appendChild(actionsCell);

                tbody.appendChild(row);
            });

            calculateSpoons();
        }

        // ===== VALIDATION FUNCTIONS =====
        
        function validateLMJOrder() {
            // Check if H comes after ME
            const meIndex = timelineData.findIndex(t => t.lmj === 'ME');
            const hIndex = timelineData.findIndex(t => t.lmj === 'H');
            
            if (meIndex >= 0 && hIndex >= 0 && hIndex < meIndex) {
                console.error('PROTOCOL VIOLATION: H must come after ME');
                // Auto-correct if possible
                if (timelineData[hIndex] && timelineData[meIndex]) {
                    const hTask = timelineData[hIndex];
                    timelineData.splice(hIndex, 1);
                    timelineData.splice(meIndex, 0, hTask);
                }
            }
        }

        function resetBBEmojis() {
            bbEmojiUsed = [];
        }

        // ===== EDITING FUNCTIONS =====
        
        function editTask(index) {
            const task = timelineData[index];
            document.getElementById('modalTime').value = task.time;
            document.getElementById('modalAmPm').value = task.ampm;
            document.getElementById('modalFixed').value = task.fixed;
            document.getElementById('modalLmj').value = task.lmj;
            document.getElementById('modalEmoji').value = task.emoji;
            document.getElementById('modalDescription').value = task.description;
            document.getElementById('modalPriority').value = task.description.includes('High') ? 'High' : 
                                                            task.description.includes('Medium') ? 'Medium' : 'Low';
            document.getElementById('modalSpoonCost').value = task.spoonCost;
            document.getElementById('modalNotes').value = task.notes;
            selectedTaskIndex = index;
            document.getElementById('taskModal').style.display = 'block';
        }

        function saveTask() {
            if (selectedTaskIndex !== null) {
                const task = timelineData[selectedTaskIndex];
                task.time = document.getElementById('modalTime').value;
                task.ampm = document.getElementById('modalAmPm').value;
                task.fixed = document.getElementById('modalFixed').value === 'true';
                task.lmj = document.getElementById('modalLmj').value;
                task.emoji = document.getElementById('modalEmoji').value;
                task.description = document.getElementById('modalDescription').value;
                task.spoonCost = parseFloat(document.getElementById('modalSpoonCost').value);
                task.notes = document.getElementById('modalNotes').value;
                
                // Track learning event
                trackLearningEvent('task_edit', {
                    taskIndex: selectedTaskIndex,
                    changes: 'manual_edit'
                });
                
                renderTimeline();
                saveAllData();
                closeModal('taskModal');
            }
        }

        function editSpoonCost(index) {
            const newCost = prompt('New spoon cost:', timelineData[index].spoonCost);
            if (newCost !== null) {
                const oldCost = timelineData[index].spoonCost;
                timelineData[index].spoonCost = parseFloat(newCost);
                
                // Track learning for spoon cost adjustments
                trackLearningEvent('spoon_adjustments', {
                    taskType: timelineData[index].lmj,
                    oldCost: oldCost,
                    newCost: parseFloat(newCost),
                    reason: 'user_adjustment'
                });
                
                renderTimeline();
                saveAllData();
            }
        }

        function editNotes(index) {
            const newNotes = prompt('Area notes:', timelineData[index].notes);
            if (newNotes !== null) {
                timelineData[index].notes = newNotes;
                renderTimeline();
                saveAllData();
            }
        }

        function toggleStatus(index) {
            const statuses = ['incomplete', 'partial', 'progress', 'complete', 'skipped', 'rescheduled'];
            const currentIndex = statuses.indexOf(timelineData[index].status);
            const nextIndex = (currentIndex + 1) % statuses.length;
            timelineData[index].status = statuses[nextIndex];
            
            // Track completion learning
            trackLearningEvent('status_change', {
                taskType: timelineData[index].lmj,
                oldStatus: statuses[currentIndex],
                newStatus: statuses[nextIndex]
            });
            
            renderTimeline();
            saveAllData();
        }

        function addNewTask() {
            const newTask = {
                time: '1200',
                ampm: 'PM',
                fixed: false,
                lmj: 'T' + timelineData.length,
                emoji: 'üìù',
                description: 'New task (Medium)',
                spoonCost: 1,
                status: 'incomplete',
                notes: 'User added'
            };
            
            timelineData.push(newTask);
            renderTimeline();
            saveAllData();
        }

        // ===== ARCHIVE SYSTEM =====
        
        function archiveTask(index) {
            const task = timelineData[index];
            task.archivedAt = new Date().toISOString();
            task.archivedReason = 'user_archive';
            
            archiveData.push(task);
            timelineData.splice(index, 1);
            
            renderTimeline();
            saveAllData();
            alert('Task archived (not deleted)');
        }

        function showArchive() {
            const section = document.getElementById('archiveSection');
            section.style.display = section.style.display === 'none' ? 'block' : 'none';
            
            if (section.style.display === 'block') {
                updateArchiveDisplay();
            }
        }

        function updateArchiveDisplay() {
            const list = document.getElementById('archiveList');
            list.innerHTML = '';
            
            archiveData.forEach((item, index) => {
                const div = document.createElement('div');
                div.innerHTML = `
                    <strong>${item.lmj}${item.emoji}</strong> ${item.description} 
                    <small>(Archived: ${new Date(item.archivedAt).toLocaleDateString()})</small>
                    <button onclick="restoreFromArchive(${index})" class="btn-success" style="padding: 2px 6px; font-size: 0.7em;">Restore</button>
                `;
                div.style.marginBottom = '5px';
                list.appendChild(div);
            });
        }

        function restoreFromArchive(index) {
            const item = archiveData[index];
            delete item.archivedAt;
            delete item.archivedReason;
            
            timelineData.push(item);
            archiveData.splice(index, 1);
            
            renderTimeline();
            updateArchiveDisplay();
            saveAllData();
        }

        // ===== UI HELPERS =====
        
        function updateTimestamp() {
            const now = new Date();
            const options = { 
                weekday: 'long', 
                year: 'numeric', 
                month: 'long', 
                day: 'numeric',
                hour: '2-digit',
                minute: '2-digit',
                hour12: true,
                timeZoneName: 'short'
            };
            document.getElementById('timestamp').textContent = now.toLocaleDateString('en-US', options);
        }

        function updateLegend() {
            document.getElementById('legend').textContent = LEGEND;
        }

        function closeModal(modalId) {
            document.getElementById(modalId).style.display = 'none';
            selectedTaskIndex = null;
        }

        function showTaskManager() {
            const section = document.getElementById('taskManager');
            section.style.display = section.style.display === 'none' ? 'block' : 'none';
        }

        function showTemplateManager() {
            const section = document.getElementById('templateManager');
            section.style.display = section.style.display === 'none' ? 'block' : 'none';
            if (section.style.display === 'block') {
                updateTemplateList();
            }
        }

        function resetDay() {
            if (confirm('Reset entire day? This will clear all tasks but preserve templates and archive.')) {
                timelineData = [];
                bbEmojiUsed = [];
                renderTimeline();
                saveAllData();
            }
        }

        function exportData() {
            const exportData = {
                timelineData,
                checkInData,
                templates,
                spoonHistory: spoonHistory.slice(-30), // Last 30 days
                learningData
            };
            
            const dataStr = JSON.stringify(exportData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            
            const link = document.createElement('a');
            link.href = url;
            link.download = `spoonpal-export-${new Date().toISOString().split('T')[0]}.json`;
            link.click();
        }

        function importData() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = function(e) {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        try {
                            const importedData = JSON.parse(e.target.result);
                            
                            if (confirm('Import data? This will overwrite current data.')) {
                                timelineData = importedData.timelineData || [];
                                checkInData = importedData.checkInData || {};
                                templates = importedData.templates || {};
                                spoonHistory = importedData.spoonHistory || [];
                                learningData = importedData.learningData || {};
                                
                                renderTimeline();
                                autoFillCheckIn();
                                updateLearningInsights();
                                saveAllData();
                                alert('Data imported successfully!');
                            }
                        } catch (error) {
                            alert('Error importing data: ' + error.message);
                        }
                    };
                    reader.readAsText(file);
                }
            };
            input.click();
        }

        function updateReferenceSection() {
            const referenceHTML = `
                <h4>Reference Section (System Use Only, Always Last)</h4>
                <div><strong>Legend:</strong> ${LEGEND}</div>
                <div><strong>Protocol Notes:</strong></div>
                <ul>
                    <li>H comes after ME in locked LMJ order - NEVER change this</li>
                    <li>Evening routines (N, ME, H, CC, DD, EE, FF, ZZ) cannot move ahead of G</li>
                    <li>Multiple BBs per day require unique emojis - no duplicates</li>
                    <li>Only one BB per day can use standard üöΩ emoji</li>
                    <li>Additional tasks slotted between B and G unless specified</li>
                    <li>Burnout advisory is guidance only - never blocks scheduling</li>
                    <li>Archive instead of delete - data preservation enforced</li>
                    <li>SpoonPal learns from your patterns automatically</li>
                </ul>
            `;
            document.getElementById('referenceSection').innerHTML = referenceHTML;
        }

        function updateNonopeLog() {
            const nonopeHTML = `
                <h4>NONOPE Log (Permanently Rejected)</h4>
                <ul>
                    <li>‚è≠Ô∏è icon for Skipped status - EXPRESSLY FORBIDDEN</li>
                    <li>H before ME in timeline - violates locked LMJ order</li>
                    <li>Duplicate BB emojis in same day - uniqueness required</li>
                    <li>Task blocking during burnout - advisory only enforced</li>
                    <li>Deleting data permanently - archive system enforced</li>
                    <li>Ignoring LMJ sequence - locked order must be preserved</li>
                </ul>
            `;
            document.getElementById('nonopeLog').innerHTML = nonopeHTML;
        }

        // ===== UTILITY FUNCTIONS =====
        
        function selectTask(index) {
            selectedTaskIndex = index;
        }

        function adjustForWeather(weather) {
            // Weather adjustments would be applied to baseline
            // This is a placeholder for weather-based spoon adjustments
        }

        // JSON deep copy helper
        JSON.deepCopy = function(obj) {
            return JSON.parse(JSON.stringify(obj));
        };

        // Initialize app on page load
        window.onload = init;
    </script>
</body>
</html>
