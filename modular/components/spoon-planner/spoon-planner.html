<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SpoonPal Protocol Timeline - Full Implementation</title>
    <style>
        body { 
            font-family: Arial, sans-serif; 
            margin: 20px; 
            background: #f5f5f5; 
            line-height: 1.4;
        }
        .container { 
            max-width: 1200px; 
            margin: 0 auto; 
            background: white; 
            padding: 20px; 
            border-radius: 8px; 
            box-shadow: 0 2px 4px rgba(0,0,0,0.1); 
        }
        .timestamp { 
            font-weight: bold; 
            font-size: 1.1em; 
            margin-bottom: 20px; 
            color: #333; 
        }
        .debt-warning {
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            color: white;
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 20px;
            font-weight: bold;
            text-align: center;
            display: none;
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }
        .debt-warning.active { display: block; }
        .debt-warning.critical {
            background: linear-gradient(45deg, #d63031, #a29bfe);
            border: 3px solid #ff7675;
        }
        .burnout-advisory {
            background: linear-gradient(45deg, #fdcb6e, #e17055);
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 20px;
            border-left: 4px solid #d63031;
            display: none;
        }
        .burnout-advisory.active { display: block; }
        .day-config {
            background: #e8f4fd;
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 20px;
        }
        .day-config input, .day-config select {
            margin: 5px;
            padding: 5px;
            border: 1px solid #ddd;
            border-radius: 3px;
        }
        .spoon-section { 
            background: #e8f4fd; 
            padding: 15px; 
            border-radius: 6px; 
            margin-bottom: 20px; 
        }
        .check-in-section {
            background: #f0f8ff;
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 20px;
        }
        .check-in-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin-top: 10px;
        }
        .check-in-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .check-in-item input, .check-in-item select {
            width: 80px;
            padding: 4px;
            border: 1px solid #ddd;
            border-radius: 3px;
        }
        .legend { 
            background: #fff3cd; 
            padding: 10px; 
            border-radius: 4px; 
            margin-bottom: 15px; 
            font-family: monospace; 
            font-size: 0.9em; 
        }
        .weather-info {
            background: #d4edda;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 15px;
            font-size: 0.9em;
        }
        table { 
            width: 100%; 
            border-collapse: collapse; 
            margin-bottom: 20px; 
        }
        th, td { 
            border: 1px solid #ddd; 
            padding: 8px; 
            text-align: left; 
            font-size: 0.9em; 
            position: relative;
        }
        th { 
            background-color: #f8f9fa; 
            font-weight: bold; 
            position: sticky;
            top: 0;
            z-index: 10;
        }
        .editable {
            cursor: pointer;
            background: #f9f9f9;
            transition: background 0.2s;
        }
        .editable:hover {
            background: #e9e9e9;
        }
        .task-row.overdue {
            background-color: #ffe6e6;
        }
        .task-row.completed {
            background-color: #e6ffe6;
            opacity: 0.7;
        }
        .task-row.rescheduled {
            background-color: #fff3cd;
        }
        .learning-insights {
            background: #fff0f5;
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 20px;
        }
        .learning-badge {
            background: #4caf50;
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 0.7em;
            margin-left: 5px;
        }
        .reference-section { 
            background: #f8f9fa; 
            padding: 15px; 
            border-radius: 6px; 
            margin-top: 20px; 
            font-family: monospace; 
            font-size: 0.85em; 
        }
        .nonope-log { 
            background: #ffe6e6; 
            padding: 15px; 
            border-radius: 6px; 
            margin-top: 15px; 
            font-family: monospace; 
            font-size: 0.85em; 
        }
        .archive-section {
            background: #f5f5f5;
            padding: 15px;
            border-radius: 6px;
            margin-top: 20px;
            max-height: 300px;
            overflow-y: auto;
        }
        button { 
            padding: 8px 16px; 
            margin: 3px; 
            border: none; 
            border-radius: 4px; 
            cursor: pointer; 
            font-size: 0.9em; 
            transition: background 0.2s;
        }
        .btn-primary { background: #007bff; color: white; }
        .btn-primary:hover { background: #0056b3; }
        .btn-success { background: #28a745; color: white; }
        .btn-success:hover { background: #1e7e34; }
        .btn-warning { background: #ffc107; color: black; }
        .btn-warning:hover { background: #e0a800; }
        .btn-danger { background: #dc3545; color: white; }
        .btn-danger:hover { background: #c82333; }
        .btn-info { background: #17a2b8; color: white; }
        .btn-info:hover { background: #138496; }
        .btn-secondary { background: #6c757d; color: white; }
        .btn-secondary:hover { background: #545b62; }
        .controls { margin-bottom: 20px; }
        .controls-row { 
            display: flex; 
            flex-wrap: wrap; 
            gap: 5px; 
            margin-bottom: 10px; 
        }
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.4);
        }
        .modal-content {
            background-color: #fefefe;
            margin: 5% auto;
            padding: 20px;
            border: 1px solid #888;
            width: 90%;
            max-width: 600px;
            border-radius: 6px;
            max-height: 80vh;
            overflow-y: auto;
        }
        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }
        .close:hover { color: black; }
        .debug-section {
            background: #f8f9fa;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
            font-family: monospace;
            font-size: 0.8em;
            max-height: 200px;
            overflow-y: auto;
        }
        .time-conflicts {
            background: #ffebee;
            border: 1px solid #f44336;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
        }
        .auto-save-indicator {
            position: fixed;
            top: 10px;
            right: 10px;
            background: #4caf50;
            color: white;
            padding: 5px 10px;
            border-radius: 3px;
            font-size: 0.8em;
            opacity: 0;
            transition: opacity 0.3s;
        }
        .auto-save-indicator.show {
            opacity: 1;
        }
        @media (max-width: 768px) {
            .container { margin: 10px; padding: 15px; }
            .controls-row { flex-direction: column; }
            button { width: 100%; margin: 2px 0; }
            .check-in-grid { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>
    <div class="container">
        <div id="timestamp" class="timestamp"></div>
        
        <!-- Auto-save indicator -->
        <div id="autoSaveIndicator" class="auto-save-indicator">Auto-saved</div>
        
        <!-- Spoon Debt Warning System -->
        <div id="debtWarning" class="debt-warning">
            <span id="debtWarningText">üö® SPOON DEBT WARNING üö®</span>
        </div>
        
        <!-- Burnout Advisory (never blocking) -->
        <div id="burnoutAdvisory" class="burnout-advisory">
            <h4>‚ö†Ô∏è Burnout Advisory (Guidance Only - Never Blocks Scheduling)</h4>
            <p id="burnoutAdvice">Consider reducing non-essential tasks and prioritizing rest.</p>
        </div>

        <!-- Day Configuration -->
        <div class="day-config">
            <h3>Day Configuration</h3>
            <label>Day Start Time: 
                <input type="time" id="dayStartTime" value="06:00" onchange="updateDayBoundaries()">
            </label>
            <label>Day End Time: 
                <input type="time" id="dayEndTime" value="23:59" onchange="updateDayBoundaries()">
            </label>
            <label>Time Zone: 
                <select id="timeZone" onchange="updateDayBoundaries()">
                    <option value="America/Denver">Mountain Time (MDT)</option>
                    <option value="America/New_York">Eastern Time</option>
                    <option value="America/Chicago">Central Time</option>
                    <option value="America/Los_Angeles">Pacific Time</option>
                </select>
            </label>
        </div>

        <!-- Automated Check-in Section -->
        <div class="check-in-section">
            <h3>Daily Check-in (Auto-populated, User Editable)</h3>
            <div class="check-in-grid">
                <div class="check-in-item">
                    <label>Pain Level (1-10):</label>
                    <input type="number" id="painLevel" min="1" max="10" value="5" onchange="saveCheckIn()">
                </div>
                <div class="check-in-item">
                    <label>Fatigue Level (1-10):</label>
                    <input type="number" id="fatigueLevel" min="1" max="10" value="5" onchange="saveCheckIn()">
                </div>
                <div class="check-in-item">
                    <label>Mood:</label>
                    <select id="moodLevel" onchange="saveCheckIn()">
                        <option value="excellent">Excellent</option>
                        <option value="good">Good</option>
                        <option value="okay" selected>Okay</option>
                        <option value="poor">Poor</option>
                        <option value="terrible">Terrible</option>
                    </select>
                </div>
                <div class="check-in-item">
                    <label>Sleep Hours:</label>
                    <input type="number" id="sleepHours" min="0" max="24" step="0.5" value="8" onchange="saveCheckIn()">
                </div>
                <div class="check-in-item">
                    <label>CPAP Usage:</label>
                    <input type="text" id="cpapUsage" value="Auto-detected" onchange="saveCheckIn()">
                </div>
                <div class="check-in-item">
                    <label>House Temp:</label>
                    <input type="number" id="houseTemp" value="68" onchange="saveCheckIn()">¬∞F
                </div>
            </div>
        </div>

        <!-- Weather Integration -->
        <div id="weatherSection" class="weather-info">
            <strong>Weather Impact:</strong> <span id="weatherInfo">Loading...</span>
            <button onclick="refreshWeather()" class="btn-info" style="padding: 2px 8px; font-size: 0.8em; margin-left: 10px;">Refresh</button>
        </div>

        <!-- Spoon Section -->
        <div id="spoonSection" class="spoon-section">
            <h3>Spoon Management</h3>
            <div>Baseline: <span id="baseline">20</span> | Borrowed: <span id="borrowed">0</span> | Start: <span id="start">20</span></div>
            <div>Planned Cost: <span id="planned">0</span> | Spent: <span id="spent">0</span> | Remaining: <span id="remaining">20</span></div>
            <div>Depletion: <span id="depletion">0</span> | Consecutive Debt Days: <span id="consecutiveDebt">0</span></div>
            <div id="timeConflicts" class="time-conflicts" style="display: none;"></div>
        </div>

        <!-- Learning Insights -->
        <div class="learning-insights">
            <h3>SpoonPal Learning Insights</h3>
            <div id="learningInsights">Analyzing your patterns...</div>
        </div>

        <!-- Enhanced Controls -->
        <div class="controls">
            <div class="controls-row">
                <button class="btn-primary" onclick="generateWeekdayTemplate()">Generate Weekday</button>
                <button class="btn-success" onclick="generateSundayTemplate()">Generate Sunday</button>
                <button class="btn-info" onclick="addNewTask()">Add Task</button>
                <button class="btn-warning" onclick="autoRescheduleAll()">Auto-Reschedule</button>
                <button class="btn-info" onclick="validateAndSort()">Sort & Validate</button>
            </div>
            <div class="controls-row">
                <button class="btn-secondary" onclick="showArchive()">View Archive</button>
                <button class="btn-secondary" onclick="exportData()">Export Data</button>
                <button class="btn-secondary" onclick="importData()">Import Data</button>
                <button class="btn-danger" onclick="resetDay()">Reset Day</button>
                <button class="btn-info" onclick="showDebugInfo()">Debug Info</button>
            </div>
        </div>

        <!-- Protocol-Locked Legend -->
        <div id="legend" class="legend"></div>
        
        <!-- Timeline Table -->
        <table id="timelineTable">
            <thead>
                <tr>
                    <th>Select</th>
                    <th>Time</th>
                    <th>Lmj</th>
                    <th>Task (Priority)</th>
                    <th>ü•Ñ</th>
                    <th>Status</th>
                    <th>AreaNotes</th>
                    <th>Actions</th>
                </tr>
            </thead>
            <tbody id="timelineBody">
            </tbody>
        </table>

        <!-- Archive Section -->
        <div id="archiveSection" class="archive-section" style="display: none;">
            <h3>Archived Items (Never Permanently Deleted)</h3>
            <div id="archiveList"></div>
            <button onclick="clearArchive()" class="btn-danger">Clear Archive (Permanent)</button>
        </div>

        <!-- Debug Section -->
        <div id="debugSection" class="debug-section" style="display: none;">
            <h4>Debug Information</h4>
            <div id="debugOutput"></div>
        </div>

        <div id="referenceSection" class="reference-section"></div>
        <div id="nonopeLog" class="nonope-log"></div>
    </div>

    <!-- Task Edit Modal -->
    <div id="taskModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal('taskModal')">&times;</span>
            <h2>Edit Task</h2>
            <form id="taskForm" onsubmit="event.preventDefault(); saveTask();">
                <p>Time: <input type="time" id="modalTime" required></p>
                <p>Fixed/Flexible: 
                    <select id="modalFixed">
                        <option value="true">Fixed üîí</option>
                        <option value="false">Flexible ‚ÜïÔ∏è</option>
                    </select>
                </p>
                <p>LMJ: <input type="text" id="modalLmj" placeholder="A" maxlength="3" required></p>
                <p>Emoji: <input type="text" id="modalEmoji" placeholder="üíä" maxlength="5" required></p>
                <p>Description: <input type="text" id="modalDescription" placeholder="Morning meds" required></p>
                <p>Priority: 
                    <select id="modalPriority">
                        <option value="High">High</option>
                        <option value="Medium">Medium</option>
                        <option value="Low">Low</option>
                        <option value="Urgent">Urgent</option>
                    </select>
                </p>
                <p>Spoon Cost: <input type="number" id="modalSpoonCost" min="0" max="10" step="0.5" required></p>
                <p>Duration (minutes): <input type="number" id="modalDuration" min="5" max="480" value="30"></p>
                <p>Area Notes: <input type="text" id="modalNotes" placeholder="Area notes"></p>
                <div style="margin-top: 15px;">
                    <button type="submit" class="btn-success">Save Task</button>
                    <button type="button" onclick="closeModal('taskModal')" class="btn-secondary">Cancel</button>
                    <button type="button" onclick="deleteCurrentTask()" class="btn-danger">Archive Task</button>
                </div>
            </form>
        </div>
    </div>

    <script>
        // ===== PROTOCOL-LOCKED DATA =====
        
        // LMJ Order from attached file - IMMUTABLE
        const LOCKED_LMJ_ORDER = [
            { lmj: 'A', emoji: 'üíä', description: 'Morning meds', defaultDuration: 15, defaultSpoonCost: 2 },
            { lmj: 'V', emoji: 'ü¶æ', description: 'CPAP prep, wrist brace', defaultDuration: 15, defaultSpoonCost: 1 },
            { lmj: 'B', emoji: 'üçΩÔ∏è', description: 'Family scriptures, breakfast', defaultDuration: 30, defaultSpoonCost: 2 },
            { lmj: 'G', emoji: 'üê•', description: 'Gosling time', defaultDuration: 60, defaultSpoonCost: 2 },
            { lmj: 'N', emoji: 'üì∞', description: 'News with Mom', defaultDuration: 30, defaultSpoonCost: 1 },
            { lmj: 'ME', emoji: 'üßò', description: 'Me time', defaultDuration: 60, defaultSpoonCost: 1 },
            { lmj: 'H', emoji: 'üß∫', description: 'Hamper/laundry (change clothes, hamper, bathroom)', defaultDuration: 30, defaultSpoonCost: 1 },
            { lmj: 'CC', emoji: 'üõèÔ∏è', description: 'In bed', defaultDuration: 15, defaultSpoonCost: 0 },
            { lmj: 'DD', emoji: 'üí®', description: 'Breathe, recover', defaultDuration: 15, defaultSpoonCost: 0 },
            { lmj: 'EE', emoji: 'üò∑', description: 'CPAP mask on', defaultDuration: 15, defaultSpoonCost: 0 },
            { lmj: 'FF', emoji: 'ü§ö', description: 'Wrist brace on', defaultDuration: 15, defaultSpoonCost: 0 },
            { lmj: 'ZZ', emoji: 'üìµ', description: 'Device off, crash', defaultDuration: 0, defaultSpoonCost: 0 }
        ];

        // Status Icons - ‚è≠Ô∏è IS EXPRESSLY FORBIDDEN
        const STATUS_ICONS = {
            complete: '‚úÖ',
            incomplete: '‚¨ú',
            partial: '‚è≥',
            progress: 'üõ†Ô∏è',
            interrupted: 'üöß', 
            skipped: '‚ùå',  // NOT ‚è≠Ô∏è which is FORBIDDEN
            rescheduled: 'üîÑ'
        };

        // Bathroom Break Emojis Pool
        const BB_EMOJIS = ['üöΩ', 'üöª', 'üöæ', 'üöΩüí®', 'üöΩüßª', 'üßªüöΩ', 'üöø', 'üõÅ', 'üöΩüåä', 'üöΩüí°'];

        // Protocol-Locked Legend
        const LEGEND = "Fixed üîí Flexible ‚ÜïÔ∏è Urgent üî• AM ‚òÄÔ∏è PM üåô ü•Ñ Spoon Lmj üéØ Status ‚úÖ Complete ‚¨ú Incomplete ‚è≥ Partial üõ†Ô∏è Progress üöß Interrupted ‚ùå Skipped üîÑ Rescheduled";

        // ===== GLOBAL STATE =====
        
        let timelineData = [];
        let archiveData = [];
        let templates = {};
        let checkInData = {};
        let spoonHistory = [];
        let selectedTaskIndex = null;
        let bbEmojiUsed = [];
        let learningData = {};
        let dayStartHour = 6;
        let dayEndHour = 23;
        let currentTimeZone = 'America/Denver';
        let debugMode = false;
        let conflictWarnings = [];

        // ===== INITIALIZATION =====
        
        function init() {
            loadAllData();
            initializeDayBoundaries();
            updateTimestamp();
            updateWeather();
            autoFillCheckIn();
            updateDebtWarning();
            updateBurnoutAdvisory();
            updateLegend();
            calculateSpoons();
            validateAndSort();
            renderTimeline();
            updateLearningInsights();
            updateReferenceSection();
            updateNonopeLog();
            
            // Set up auto-save and refresh intervals
            setInterval(updateTimestamp, 60000);
            setInterval(autoSave, 30000);
            setInterval(checkOverdueTasks, 300000); // Check for overdue tasks every 5 minutes
            
            debugLog('System initialized successfully');
        }

        // ===== PERSISTENCE FUNCTIONS =====
        
        function saveAllData() {
            const saveData = {
                timelineData,
                archiveData,
                templates,
                checkInData,
                spoonHistory,
                bbEmojiUsed,
                learningData,
                dayStartHour,
                dayEndHour,
                currentTimeZone,
                lastSave: new Date().toISOString(),
                version: '2.0'
            };
            localStorage.setItem('spoonPalData', JSON.stringify(saveData));
            showAutoSaveIndicator();
            debugLog('Data saved successfully');
        }

        function loadAllData() {
            const saved = localStorage.getItem('spoonPalData');
            if (saved) {
                try {
                    const data = JSON.parse(saved);
                    timelineData = data.timelineData || [];
                    archiveData = data.archiveData || [];
                    templates = data.templates || {};
                    checkInData = data.checkInData || {};
                    spoonHistory = data.spoonHistory || [];
                    bbEmojiUsed = data.bbEmojiUsed || [];
                    learningData = data.learningData || {};
                    dayStartHour = data.dayStartHour || 6;
                    dayEndHour = data.dayEndHour || 23;
                    currentTimeZone = data.currentTimeZone || 'America/Denver';
                    debugLog('Data loaded successfully, version: ' + (data.version || '1.0'));
                } catch (error) {
                    debugLog('Error loading data: ' + error.message);
                    console.error('Error loading saved data:', error);
                }
            }
        }

        function autoSave() {
            saveAllData();
            debugLog('Auto-saved at ' + new Date().toLocaleTimeString());
        }

        function showAutoSaveIndicator() {
            const indicator = document.getElementById('autoSaveIndicator');
            indicator.classList.add('show');
            setTimeout(() => {
                indicator.classList.remove('show');
            }, 2000);
        }

        // ===== DAY BOUNDARY MANAGEMENT =====
        
        function initializeDayBoundaries() {
            document.getElementById('dayStartTime').value = String(dayStartHour).padStart(2, '0') + ':00';
            document.getElementById('dayEndTime').value = String(dayEndHour).padStart(2, '0') + ':59';
            document.getElementById('timeZone').value = currentTimeZone;
        }

        function updateDayBoundaries() {
            const startTime = document.getElementById('dayStartTime').value;
            const endTime = document.getElementById('dayEndTime').value;
            currentTimeZone = document.getElementById('timeZone').value;
            
            dayStartHour = parseInt(startTime.split(':')[0]);
            dayEndHour = parseInt(endTime.split(':')[0]);
            
            debugLog(`Day boundaries updated: ${dayStartHour}:00 to ${dayEndHour}:59`);
            
            // Recalculate everything based on new day boundaries
            validateAndSort();
            calculateSpoons();
            renderTimeline();
            saveAllData();
        }

        function getCurrentDayTime() {
            const now = new Date();
            const currentHour = now.getHours();
            const currentMinute = now.getMinutes();
            
            // Adjust for custom day boundaries
            let adjustedHour = currentHour;
            if (currentHour < dayStartHour) {
                adjustedHour += 24; // Next day
            }
            
            return {
                hour: adjustedHour,
                minute: currentMinute,
                timeString: String(currentHour).padStart(2, '0') + ':' + String(currentMinute).padStart(2, '0'),
                isWithinDay: currentHour >= dayStartHour && currentHour <= dayEndHour
            };
        }

        // ===== CHECK-IN AUTOMATION =====
        
        function autoFillCheckIn() {
            const today = new Date().toDateString();
            
            if (!checkInData[today]) {
                checkInData[today] = {
                    painLevel: getPredictedPain(),
                    fatigueLevel: getPredictedFatigue(),
                    mood: 'okay',
                    sleepHours: getLastNightSleep(),
                    cpapUsage: 'Auto-detected',
                    houseTemp: 68
                };
            }

            // Update UI
            document.getElementById('painLevel').value = checkInData[today].painLevel;
            document.getElementById('fatigueLevel').value = checkInData[today].fatigueLevel;
            document.getElementById('moodLevel').value = checkInData[today].mood;
            document.getElementById('sleepHours').value = checkInData[today].sleepHours;
            document.getElementById('cpapUsage').value = checkInData[today].cpapUsage;
            document.getElementById('houseTemp').value = checkInData[today].houseTemp;
        }

        function saveCheckIn() {
            const today = new Date().toDateString();
            checkInData[today] = {
                painLevel: parseInt(document.getElementById('painLevel').value),
                fatigueLevel: parseInt(document.getElementById('fatigueLevel').value),
                mood: document.getElementById('moodLevel').value,
                sleepHours: parseFloat(document.getElementById('sleepHours').value),
                cpapUsage: document.getElementById('cpapUsage').value,
                houseTemp: parseInt(document.getElementById('houseTemp').value),
                timestamp: new Date().toISOString()
            };
            
            // Recalculate everything based on check-in
            adjustBaseline();
            calculateSpoons();
            updateDebtWarning();
            updateBurnoutAdvisory();
            updateLearningInsights();
            saveAllData();
            
            debugLog('Check-in saved and calculations updated');
        }

        // ===== SPOON DEBT WARNING SYSTEM =====
        
        function updateDebtWarning() {
            const consecutiveDays = getConsecutiveDebtDays();
            const warningEl = document.getElementById('debtWarning');
            const textEl = document.getElementById('debtWarningText');
            
            document.getElementById('consecutiveDebt').textContent = consecutiveDays;
            
            if (consecutiveDays >= 2) {
                warningEl.classList.add('active');
                if (consecutiveDays >= 5) {
                    warningEl.classList.add('critical');
                    textEl.textContent = `üÜò CRITICAL DEBT PERIOD üÜò Day ${consecutiveDays} - medical crisis territory`;
                } else if (consecutiveDays === 3) {
                    textEl.textContent = '‚ö†Ô∏è BURNOUT RISK ZONE ‚ö†Ô∏è Day 3 in debt - entering burnout risk';
                } else if (consecutiveDays === 2) {
                    textEl.textContent = 'üö® SPOON DEBT WARNING üö® Day 2 of consecutive debt';
                } else {
                    textEl.textContent = `üö® EXTENDED DEBT üö® Day ${consecutiveDays} of consecutive spoon debt`;
                }
            } else {
                warningEl.classList.remove('active', 'critical');
            }
        }

        function getConsecutiveDebtDays() {
            if (spoonHistory.length === 0) return 0;
            
            let consecutiveDays = 0;
            for (let i = spoonHistory.length - 1; i >= 0; i--) {
                if (spoonHistory[i].endBalance < 0) {
                    consecutiveDays++;
                } else {
                    break;
                }
            }
            return consecutiveDays;
        }

        // ===== BURNOUT ADVISORY (NON-BLOCKING) =====
        
        function updateBurnoutAdvisory() {
            const advisoryEl = document.getElementById('burnoutAdvisory');
            const adviceEl = document.getElementById('burnoutAdvice');
            
            const consecutiveDays = getConsecutiveDebtDays();
            const currentPain = parseInt(document.getElementById('painLevel').value);
            const currentFatigue = parseInt(document.getElementById('fatigueLevel').value);
            const currentRemaining = parseFloat(document.getElementById('remaining').textContent);
            
            if (consecutiveDays >= 3 || currentPain >= 8 || currentFatigue >= 8 || currentRemaining < 5) {
                advisoryEl.classList.add('active');
                
                let advice = '‚ö†Ô∏è ADVISORY ONLY - This guidance never blocks task scheduling. ';
                if (consecutiveDays >= 3) advice += `${consecutiveDays} days of spoon debt detected. `;
                if (currentPain >= 8) advice += 'High pain level - extra rest recommended. ';
                if (currentFatigue >= 8) advice += 'High fatigue - limit demanding activities. ';
                if (currentRemaining < 5) advice += 'Very low spoon reserves - prioritize essentials. ';
                advice += 'You maintain full control over all scheduling decisions.';
                
                adviceEl.textContent = advice;
            } else {
                advisoryEl.classList.remove('active');
            }
        }

        // ===== WEATHER INTEGRATION =====
        
        function updateWeather() {
            setTimeout(() => {
                const weather = generateMockWeather();
                document.getElementById('weatherInfo').textContent = weather.description;
                adjustForWeather(weather);
            }, 1000);
        }

        function refreshWeather() {
            document.getElementById('weatherInfo').textContent = 'Updating...';
            updateWeather();
        }

        function generateMockWeather() {
            const conditions = [
                { temp: 75, condition: 'sunny', spoonImpact: 0, description: '75¬∞F Sunny - Ideal conditions, no spoon penalty' },
                { temp: 60, condition: 'cold', spoonImpact: -3, description: '60¬∞F Cold - Reduces available spoons by 3' },
                { temp: 85, condition: 'hot', spoonImpact: -1, description: '85¬∞F Hot - Slight spoon reduction, stay hydrated' },
                { temp: 68, condition: 'cloudy', spoonImpact: -1, description: '68¬∞F Cloudy - Mild impact on energy' }
            ];
            return conditions[Math.floor(Math.random() * conditions.length)];
        }

        function adjustForWeather(weather) {
            // This would adjust baseline based on weather
            debugLog(`Weather adjustment: ${weather.spoonImpact} spoons`);
        }

        // ===== COMPREHENSIVE AUTO-RESCHEDULING =====
        
        function autoRescheduleAll() {
            const currentTime = getCurrentDayTime();
            const currentMinutes = currentTime.hour * 60 + currentTime.minute;
            let rescheduledCount = 0;
            
            debugLog(`Starting auto-reschedule at ${currentTime.timeString}`);
            
            // Find tasks that need rescheduling
            const tasksToReschedule = timelineData.filter((task, index) => {
                const taskMinutes = timeToMinutes(task.time);
                return (
                    task.status === 'incomplete' && 
                    !task.fixed && 
                    (task.priority === 'High' || task.priority === 'Urgent') &&
                    taskMinutes < currentMinutes
                );
            });
            
            debugLog(`Found ${tasksToReschedule.length} tasks to reschedule`);
            
            // Reschedule each task
            tasksToReschedule.forEach(task => {
                const newSlot = findNextAvailableSlot(currentMinutes, task.duration || 30);
                if (newSlot) {
                    task.time = minutesToTime(newSlot.start);
                    task.status = 'rescheduled';
                    task.notes = (task.notes || '') + ' [Auto-rescheduled]';
                    rescheduledCount++;
                    
                    trackLearningEvent('auto_reschedule', {
                        taskType: task.lmj,
                        originalTime: task.time,
                        newTime: minutesToTime(newSlot.start),
                        reason: 'missed_high_priority'
                    });
                    
                    debugLog(`Rescheduled ${task.lmj} to ${minutesToTime(newSlot.start)}`);
                }
            });
            
            // Resort timeline and update UI
            validateAndSort();
            renderTimeline();
            calculateSpoons();
            saveAllData();
            
            alert(`Auto-rescheduling completed. ${rescheduledCount} tasks rescheduled.`);
            debugLog(`Auto-reschedule completed: ${rescheduledCount} tasks moved`);
        }

        function findNextAvailableSlot(afterMinutes, durationMinutes) {
            const dayEndMinutes = dayEndHour * 60 + 59;
            const currentTime = getCurrentDayTime();
            
            // Create array of busy periods
            const busyPeriods = timelineData
                .filter(task => task.status !== 'skipped' && task.status !== 'complete')
                .map(task => ({
                    start: timeToMinutes(task.time),
                    end: timeToMinutes(task.time) + (task.duration || 30)
                }))
                .sort((a, b) => a.start - b.start);
            
            // Find first available slot
            let searchStart = Math.max(afterMinutes + 15, currentTime.hour * 60 + currentTime.minute + 15);
            
            while (searchStart + durationMinutes <= dayEndMinutes) {
                const proposedEnd = searchStart + durationMinutes;
                
                // Check if this slot conflicts with any busy period
                const hasConflict = busyPeriods.some(busy => 
                    (searchStart < busy.end && proposedEnd > busy.start)
                );
                
                if (!hasConflict) {
                    debugLog(`Found available slot: ${minutesToTime(searchStart)} - ${minutesToTime(proposedEnd)}`);
                    return { start: searchStart, end: proposedEnd };
                }
                
                // Move to next potential slot (15-minute increments)
                searchStart += 15;
            }
            
            debugLog(`No available slot found after ${minutesToTime(afterMinutes)}`);
            return null;
        }

        // ===== TASK MANAGEMENT WITH CASCADING UPDATES =====
        
        function editTask(index) {
            selectedTaskIndex = index;
            const task = timelineData[index];
            
            document.getElementById('modalTime').value = task.time;
            document.getElementById('modalFixed').value = task.fixed;
            document.getElementById('modalLmj').value = task.lmj;
            document.getElementById('modalEmoji').value = task.emoji;
            document.getElementById('modalDescription').value = task.description.replace(/ \(.*\)$/, '');
            
            const priority = task.description.match(/\((.*?)\)/);
            document.getElementById('modalPriority').value = priority ? priority[1] : 'Medium';
            
            document.getElementById('modalSpoonCost').value = task.spoonCost;
            document.getElementById('modalDuration').value = task.duration || 30;
            document.getElementById('modalNotes').value = task.notes || '';
            
            document.getElementById('taskModal').style.display = 'block';
        }

        function saveTask() {
            if (selectedTaskIndex === null) return;
            
            const task = timelineData[selectedTaskIndex];
            const oldTime = task.time;
            
            // Update task properties
            task.time = document.getElementById('modalTime').value;
            task.fixed = document.getElementById('modalFixed').value === 'true';
            task.lmj = document.getElementById('modalLmj').value;
            task.emoji = document.getElementById('modalEmoji').value;
            const description = document.getElementById('modalDescription').value;
            const priority = document.getElementById('modalPriority').value;
            task.description = `${description} (${priority})`;
            task.spoonCost = parseFloat(document.getElementById('modalSpoonCost').value);
            task.duration = parseInt(document.getElementById('modalDuration').value);
            task.notes = document.getElementById('modalNotes').value;
            
            // Track learning
            trackLearningEvent('task_edit', {
                taskIndex: selectedTaskIndex,
                oldTime: oldTime,
                newTime: task.time,
                changes: 'manual_edit'
            });
            
            debugLog(`Task ${task.lmj} edited: ${oldTime} -> ${task.time}`);
            
            // Cascade timeline updates
            cascadeTimelineUpdates();
            
            closeModal('taskModal');
        }

        function cascadeTimelineUpdates() {
            // Resort timeline
            validateAndSort();
            
            // Check for conflicts and adjust
            resolveTimeConflicts();
            
            // Update UI
            renderTimeline();
            calculateSpoons();
            saveAllData();
            
            debugLog('Timeline cascaded and updated');
        }

        function addNewTask() {
            const currentTime = getCurrentDayTime();
            const defaultTime = minutesToTime(currentTime.hour * 60 + currentTime.minute + 30);
            
            const newTask = {
                time: defaultTime,
                fixed: false,
                lmj: 'T' + Date.now().toString().slice(-3),
                emoji: 'üìù',
                description: 'New task (Medium)',
                spoonCost: 1,
                duration: 30,
                status: 'incomplete',
                notes: 'User added',
                created: new Date().toISOString()
            };
            
            timelineData.push(newTask);
            
            // Immediately sort and validate
            validateAndSort();
            renderTimeline();
            calculateSpoons();
            saveAllData();
            
            debugLog(`New task added: ${newTask.lmj} at ${newTask.time}`);
        }

        function deleteCurrentTask() {
            if (selectedTaskIndex !== null) {
                const task = timelineData[selectedTaskIndex];
                archiveTask(selectedTaskIndex);
                closeModal('taskModal');
            }
        }

        function archiveTask(index) {
            const task = timelineData[index];
            task.archivedAt = new Date().toISOString();
            task.archivedReason = 'user_archive';
            
            archiveData.push(task);
            timelineData.splice(index, 1);
            
            // Update everything after removal
            validateAndSort();
            renderTimeline();
            calculateSpoons();
            saveAllData();
            
            debugLog(`Task ${task.lmj} archived`);
            alert('Task archived (not deleted) - preserved in archive');
        }

        // ===== COMPREHENSIVE SORTING AND VALIDATION =====
        
        function validateAndSort() {
            // Validate LMJ order compliance
            validateLMJOrder();
            
            // Sort timeline by time and LMJ priority
            timelineData.sort((a, b) => {
                const aMinutes = timeToMinutes(a.time);
                const bMinutes = timeToMinutes(b.time);
                
                if (aMinutes !== bMinutes) {
                    return aMinutes - bMinutes;
                }
                
                // If same time, sort by LMJ order
                const aLmjIndex = LOCKED_LMJ_ORDER.findIndex(lmj => lmj.lmj === a.lmj);
                const bLmjIndex = LOCKED_LMJ_ORDER.findIndex(lmj => lmj.lmj === b.lmj);
                
                if (aLmjIndex >= 0 && bLmjIndex >= 0) {
                    return aLmjIndex - bLmjIndex;
                }
                
                return 0;
            });
            
            // Check for time conflicts
            detectTimeConflicts();
            
            debugLog('Timeline validated and sorted');
        }

        function validateLMJOrder() {
            // Check critical protocol: H must come after ME
            const meTask = timelineData.find(t => t.lmj === 'ME');
            const hTask = timelineData.find(t => t.lmj === 'H');
            
            if (meTask && hTask) {
                const meMinutes = timeToMinutes(meTask.time);
                const hMinutes = timeToMinutes(hTask.time);
                
                if (hMinutes <= meMinutes) {
                    // Auto-correct protocol violation
                    hTask.time = minutesToTime(meMinutes + 30);
                    debugLog('PROTOCOL VIOLATION CORRECTED: H moved after ME');
                }
            }
            
            // Validate no duplicate LMJ codes
            const lmjCounts = {};
            timelineData.forEach(task => {
                lmjCounts[task.lmj] = (lmjCounts[task.lmj] || 0) + 1;
            });
            
            Object.keys(lmjCounts).forEach(lmj => {
                if (lmjCounts[lmj] > 1) {
                    debugLog(`WARNING: Duplicate LMJ code ${lmj} found`);
                }
            });
        }

        function detectTimeConflicts() {
            conflictWarnings = [];
            const conflicts = document.getElementById('timeConflicts');
            
            for (let i = 0; i < timelineData.length - 1; i++) {
                const current = timelineData[i];
                const next = timelineData[i + 1];
                
                if (current.status === 'skipped' || next.status === 'skipped') continue;
                
                const currentEnd = timeToMinutes(current.time) + (current.duration || 30);
                const nextStart = timeToMinutes(next.time);
                
                if (currentEnd > nextStart) {
                    const conflict = `‚ö†Ô∏è Time conflict: ${current.lmj} ends at ${minutesToTime(currentEnd)} but ${next.lmj} starts at ${next.time}`;
                    conflictWarnings.push(conflict);
                }
            }
            
            if (conflictWarnings.length > 0) {
                conflicts.style.display = 'block';
                conflicts.innerHTML = '<strong>Time Conflicts Detected:</strong><br>' + conflictWarnings.join('<br>');
            } else {
                conflicts.style.display = 'none';
            }
        }

        function resolveTimeConflicts() {
            let resolved = 0;
            
            for (let i = 0; i < timelineData.length - 1; i++) {
                const current = timelineData[i];
                const next = timelineData[i + 1];
                
                if (current.status === 'skipped' || next.status === 'skipped') continue;
                if (next.fixed) continue; // Don't move fixed tasks
                
                const currentEnd = timeToMinutes(current.time) + (current.duration || 30);
                const nextStart = timeToMinutes(next.time);
                
                if (currentEnd > nextStart) {
                    // Move next task to after current task ends
                    next.time = minutesToTime(currentEnd + 5); // 5-minute buffer
                    resolved++;
                    debugLog(`Conflict resolved: moved ${next.lmj} to ${next.time}`);
                }
            }
            
            if (resolved > 0) {
                debugLog(`Resolved ${resolved} time conflicts`);
            }
        }

        // ===== UTILITY FUNCTIONS =====
        
        function timeToMinutes(timeString) {
            const [hours, minutes] = timeString.split(':').map(Number);
            return hours * 60 + minutes;
        }

        function minutesToTime(minutes) {
            const hours = Math.floor(minutes / 60);
            const mins = minutes % 60;
            return String(hours).padStart(2, '0') + ':' + String(mins).padStart(2, '0');
        }

        function checkOverdueTasks() {
            const currentTime = getCurrentDayTime();
            const currentMinutes = currentTime.hour * 60 + currentTime.minute;
            
            timelineData.forEach(task => {
                const taskMinutes = timeToMinutes(task.time);
                if (task.status === 'incomplete' && taskMinutes < currentMinutes - 15) {
                    // Mark as overdue
                    task.overdue = true;
                }
            });
            
            renderTimeline();
        }

        // ===== LEARNING SYSTEM =====
        
        function trackLearningEvent(eventType, data) {
            if (!learningData[eventType]) {
                learningData[eventType] = [];
            }
            learningData[eventType].push({
                timestamp: new Date().toISOString(),
                data: data
            });
            
            // Limit history to last 100 events per type
            if (learningData[eventType].length > 100) {
                learningData[eventType] = learningData[eventType].slice(-100);
            }
        }

        function updateLearningInsights() {
            const insights = generateLearningInsights();
            document.getElementById('learningInsights').innerHTML = insights;
        }

        function generateLearningInsights() {
            let insights = '';
            
            // Analyze completion patterns
            const completedToday = timelineData.filter(t => t.status === 'complete');
            if (completedToday.length > 0) {
                insights += `<span class="learning-badge">TODAY</span> Completed ${completedToday.length} tasks. `;
            }
            
            // Analyze spoon accuracy
            if (learningData.spoon_adjustments && learningData.spoon_adjustments.length > 5) {
                const recentAdjustments = learningData.spoon_adjustments.slice(-10);
                const avgAdjustment = recentAdjustments.reduce((sum, adj) => 
                    sum + (adj.data.newCost - adj.data.oldCost), 0) / recentAdjustments.length;
                
                if (Math.abs(avgAdjustment) > 0.5) {
                    insights += `<span class="learning-badge">LEARNING</span> Spoon estimates adjusting by ${avgAdjustment.toFixed(1)} on average. `;
                }
            }
            
            // Analyze timing patterns
            const morningTasks = timelineData.filter(t => 
                timeToMinutes(t.time) < 720 && t.status === 'complete'
            );
            if (morningTasks.length >= 3) {
                insights += `<span class="learning-badge">PATTERN</span> Morning productivity detected. `;
            }
            
            // Analyze rescheduling patterns
            if (learningData.auto_reschedule && learningData.auto_reschedule.length > 3) {
                insights += `<span class="learning-badge">ADAPTIVE</span> Learning from ${learningData.auto_reschedule.length} rescheduling events. `;
            }
            
            if (!insights) {
                insights = 'Building learning profile... Complete more tasks to see personalized insights.';
            }
            
            return insights;
        }

        // ===== PREDICTION HELPERS =====
        
        function getPredictedPain() {
            const recent = Object.values(checkInData).slice(-7);
            if (recent.length === 0) return 5;
            const avg = recent.reduce((sum, day) => sum + day.painLevel, 0) / recent.length;
            return Math.round(avg);
        }

        function getPredictedFatigue() {
            const recent = Object.values(checkInData).slice(-7);
            if (recent.length === 0) return 5;
            const avg = recent.reduce((sum, day) => sum + day.fatigueLevel, 0) / recent.length;
            return Math.round(avg);
        }

        function getLastNightSleep() {
            const recent = Object.values(checkInData).slice(-1)[0];
            return recent ? recent.sleepHours : 8;
        }

        // ===== SPOON CALCULATIONS =====
        
        function adjustBaseline() {
            let baseline = 20;
            const pain = parseInt(document.getElementById('painLevel').value);
            const fatigue = parseInt(document.getElementById('fatigueLevel').value);
            const sleep = parseFloat(document.getElementById('sleepHours').value);
            const temp = parseInt(document.getElementById('houseTemp').value);
            const mood = document.getElementById('moodLevel').value;
            
            // Adjust for pain (higher pain = fewer spoons)
            baseline -= Math.max(0, (pain - 5));
            
            // Adjust for fatigue
            baseline -= Math.max(0, (fatigue - 5));
            
            // Adjust for sleep
            if (sleep < 7) {
                baseline -= (7 - sleep) * 2;
            } else if (sleep > 9) {
                baseline += Math.min(3, (sleep - 9));
            }
            
            // Adjust for temperature
            if (temp < 70) {
                baseline -= Math.floor((70 - temp) / 5);
            }
            
            // Adjust for mood
            const moodAdjustments = {
                'terrible': -3,
                'poor': -1,
                'okay': 0,
                'good': 1,
                'excellent': 2
            };
            baseline += moodAdjustments[mood] || 0;
            
            baseline = Math.max(1, baseline);
            document.getElementById('baseline').textContent = baseline;
            
            debugLog(`Baseline adjusted to ${baseline} based on check-in data`);
        }

        function calculateSpoons() {
            const baseline = parseInt(document.getElementById('baseline').textContent);
            const borrowed = parseInt(document.getElementById('borrowed').textContent);
            const start = baseline - borrowed;
            const planned = timelineData.reduce((sum, task) => sum + task.spoonCost, 0);
            const spent = timelineData.filter(task => 
                task.status === 'complete' || task.status === 'partial'
            ).reduce((sum, task) => sum + (task.status === 'partial' ? task.spoonCost * 0.5 : task.spoonCost), 0);
            const remaining = start - spent;
            const depletion = remaining - (planned - spent);

            document.getElementById('start').textContent = start;
            document.getElementById('planned').textContent = planned.toFixed(1);
            document.getElementById('spent').textContent = spent.toFixed(1);
            document.getElementById('remaining').textContent = remaining.toFixed(1);
            document.getElementById('depletion').textContent = depletion.toFixed(1);
            
            // Store daily spoon data
            const today = new Date().toDateString();
            spoonHistory = spoonHistory.filter(entry => entry.date !== today);
            spoonHistory.push({
                date: today,
                baseline: baseline,
                borrowed: borrowed,
                spent: spent,
                endBalance: depletion,
                timestamp: new Date().toISOString()
            });
            
            // Keep only last 30 days
            spoonHistory = spoonHistory.slice(-30);
        }

        // ===== TEMPLATE SYSTEM =====
        
        function generateWeekdayTemplate() {
            timelineData = [];
            let currentTime = dayStartHour * 60 + 30; // Start 30 minutes after day start
            
            LOCKED_LMJ_ORDER.forEach((lmjData, index) => {
                // Calculate appropriate time spacing
                const timeSpacing = index < 3 ? 30 : 60; // Closer spacing for morning tasks
                
                const task = {
                    time: minutesToTime(currentTime),
                    fixed: ['A', 'V', 'CC', 'DD', 'EE', 'FF', 'ZZ'].includes(lmjData.lmj),
                    lmj: lmjData.lmj,
                    emoji: lmjData.emoji,
                    description: `${lmjData.description} (High)`,
                    spoonCost: lmjData.defaultSpoonCost,
                    duration: lmjData.defaultDuration,
                    status: 'incomplete',
                    notes: 'Generated from weekday template',
                    created: new Date().toISOString()
                };
                
                timelineData.push(task);
                currentTime += timeSpacing;
                
                // Add bathroom breaks between some tasks
                if (['B', 'G', 'N'].includes(lmjData.lmj)) {
                    const bbTask = {
                        time: minutesToTime(currentTime),
                        fixed: false,
                        lmj: 'BB' + (bbEmojiUsed.length + 1),
                        emoji: getNextBBEmoji(),
                        description: 'Bathroom break (High)',
                        spoonCost: 0,
                        duration: 15,
                        status: 'incomplete',
                        notes: 'Auto-scheduled bathroom break'
                    };
                    timelineData.push(bbTask);
                    currentTime += 15;
                }
            });
            
            validateAndSort();
            calculateSpoons();
            renderTimeline();
            saveAllData();
            
            debugLog('Weekday template generated with LMJ order compliance');
        }

        function generateSundayTemplate() {
            // Sunday: Only essential and explicitly allowed tasks
            timelineData = [
                {
                    time: minutesToTime(dayStartHour * 60 + 90),
                    fixed: true,
                    lmj: 'A',
                    emoji: 'üíä',
                    description: 'Morning meds (High)',
                    spoonCost: 2,
                    duration: 15,
                    status: 'incomplete',
                    notes: 'Essential medication'
                },
                {
                    time: '11:30',
                    fixed: true,
                    lmj: 'CH',
                    emoji: '‚õ™',
                    description: 'Church service (Highest)',
                    spoonCost: 3,
                    duration: 180,
                    status: 'incomplete',
                    notes: 'Fixed religious observance'
                },
                {
                    time: '18:00',
                    fixed: false,
                    lmj: 'N',
                    emoji: 'üì∞',
                    description: 'News with Mom (High)',
                    spoonCost: 1,
                    duration: 30,
                    status: 'incomplete',
                    notes: 'Evening routine'
                },
                {
                    time: minutesToTime(dayEndHour * 60 - 60),
                    fixed: true,
                    lmj: 'ZZ',
                    emoji: 'üìµ',
                    description: 'Device off, rest (High)',
                    spoonCost: 0,
                    duration: 0,
                    status: 'incomplete',
                    notes: 'Sunday rest'
                }
            ];
            
            bbEmojiUsed = [];
            validateAndSort();
            calculateSpoons();
            renderTimeline();
            saveAllData();
            
            debugLog('Sunday template generated - restricted schedule');
        }

        function getNextBBEmoji() {
            const availableEmojis = BB_EMOJIS.filter(emoji => !bbEmojiUsed.includes(emoji));
            if (availableEmojis.length === 0) {
                // Reset if all used
                bbEmojiUsed = [];
                return BB_EMOJIS[0];
            }
            
            const nextEmoji = availableEmojis[0];
            bbEmojiUsed.push(nextEmoji);
            return nextEmoji;
        }

        // ===== TIMELINE RENDERING =====
        
        function renderTimeline() {
            const tbody = document.getElementById('timelineBody');
            tbody.innerHTML = '';
            
            timelineData.forEach((task, index) => {
                const row = document.createElement('tr');
                row.className = 'task-row';
                
                // Apply visual indicators
                if (task.overdue) row.classList.add('overdue');
                if (task.status === 'complete') row.classList.add('completed');
                if (task.status === 'rescheduled') row.classList.add('rescheduled');
                
                // Selection checkbox
                const selectCell = document.createElement('td');
                selectCell.innerHTML = `<input type="checkbox" onchange="selectTask(${index})">`;
                row.appendChild(selectCell);
                
                // Time with icons
                const timeCell = document.createElement('td');
                const timeMinutes = timeToMinutes(task.time);
                const ampm = timeMinutes >= 720 ? 'üåô' : '‚òÄÔ∏è';
                const flexIcon = task.fixed ? 'üîí' : '‚ÜïÔ∏è';
                timeCell.innerHTML = `${task.time} ${ampm} ${flexIcon}`;
                row.appendChild(timeCell);

                // LMJ with emoji
                const lmjCell = document.createElement('td');
                lmjCell.innerHTML = `${task.lmj}${task.emoji}`;
                row.appendChild(lmjCell);

                // Task description (editable)
                const taskCell = document.createElement('td');
                taskCell.innerHTML = task.description;
                taskCell.className = 'editable';
                taskCell.onclick = () => editTask(index);
                taskCell.title = 'Click to edit';
                row.appendChild(taskCell);

                // Spoon cost (editable)
                const spoonCell = document.createElement('td');
                spoonCell.innerHTML = task.spoonCost;
                spoonCell.className = 'editable';
                spoonCell.onclick = () => editSpoonCost(index);
                spoonCell.title = 'Click to edit spoon cost';
                row.appendChild(spoonCell);

                // Status (clickable)
                const statusCell = document.createElement('td');
                statusCell.innerHTML = STATUS_ICONS[task.status];
                statusCell.style.cursor = 'pointer';
                statusCell.onclick = () => toggleStatus(index);
                statusCell.title = 'Click to change status';
                row.appendChild(statusCell);

                // Area notes (editable)
                const notesCell = document.createElement('td');
                notesCell.innerHTML = task.notes || '';
                notesCell.className = 'editable';
                notesCell.onclick = () => editNotes(index);
                notesCell.title = 'Click to edit notes';
                row.appendChild(notesCell);

                // Actions
                const actionsCell = document.createElement('td');
                actionsCell.innerHTML = `
                    <button onclick="editTask(${index})" class="btn-warning" style="padding: 2px 6px; font-size: 0.7em;">Edit</button>
                    <button onclick="archiveTask(${index})" class="btn-secondary" style="padding: 2px 6px; font-size: 0.7em;">Archive</button>
                `;
                row.appendChild(actionsCell);

                tbody.appendChild(row);
            });

            calculateSpoons();
        }

        // ===== EDITING FUNCTIONS =====
        
        function editSpoonCost(index) {
            const newCost = prompt('New spoon cost:', timelineData[index].spoonCost);
            if (newCost !== null && !isNaN(newCost)) {
                const oldCost = timelineData[index].spoonCost;
                timelineData[index].spoonCost = parseFloat(newCost);
                
                trackLearningEvent('spoon_adjustments', {
                    taskType: timelineData[index].lmj,
                    oldCost: oldCost,
                    newCost: parseFloat(newCost),
                    reason: 'user_adjustment'
                });
                
                renderTimeline();
                saveAllData();
                debugLog(`Spoon cost updated for ${timelineData[index].lmj}: ${oldCost} -> ${newCost}`);
            }
        }

        function editNotes(index) {
            const newNotes = prompt('Area notes:', timelineData[index].notes || '');
            if (newNotes !== null) {
                timelineData[index].notes = newNotes;
                renderTimeline();
                saveAllData();
            }
        }

        function toggleStatus(index) {
            const statuses = ['incomplete', 'partial', 'progress', 'complete', 'skipped', 'rescheduled'];
            const currentIndex = statuses.indexOf(timelineData[index].status);
            const nextIndex = (currentIndex + 1) % statuses.length;
            const oldStatus = timelineData[index].status;
            timelineData[index].status = statuses[nextIndex];
            
            trackLearningEvent('status_change', {
                taskType: timelineData[index].lmj,
                oldStatus: oldStatus,
                newStatus: statuses[nextIndex],
                timestamp: new Date().toISOString()
            });
            
            renderTimeline();
            saveAllData();
            debugLog(`Status changed for ${timelineData[index].lmj}: ${oldStatus} -> ${statuses[nextIndex]}`);
        }

        // ===== ARCHIVE SYSTEM =====
        
        function showArchive() {
            const section = document.getElementById('archiveSection');
            section.style.display = section.style.display === 'none' ? 'block' : 'none';
            
            if (section.style.display === 'block') {
                updateArchiveDisplay();
            }
        }

        function updateArchiveDisplay() {
            const list = document.getElementById('archiveList');
            list.innerHTML = '';
            
            archiveData.forEach((item, index) => {
                const div = document.createElement('div');
                div.innerHTML = `
                    <strong>${item.lmj}${item.emoji}</strong> ${item.description} 
                    <small>(Archived: ${new Date(item.archivedAt).toLocaleDateString()})</small>
                    <button onclick="restoreFromArchive(${index})" class="btn-success" style="padding: 2px 6px; font-size: 0.7em;">Restore</button>
                `;
                div.style.marginBottom = '5px';
                list.appendChild(div);
            });
            
            if (archiveData.length === 0) {
                list.innerHTML = '<em>No archived items</em>';
            }
        }

        function restoreFromArchive(index) {
            const item = archiveData[index];
            delete item.archivedAt;
            delete item.archivedReason;
            
            timelineData.push(item);
            archiveData.splice(index, 1);
            
            validateAndSort();
            renderTimeline();
            updateArchiveDisplay();
            saveAllData();
            
            debugLog(`Restored ${item.lmj} from archive`);
        }

        function clearArchive() {
            if (confirm('Permanently delete all archived items? This cannot be undone.')) {
                archiveData = [];
                updateArchiveDisplay();
                saveAllData();
                debugLog('Archive cleared permanently');
            }
        }

        // ===== DEBUG SYSTEM =====
        
        function debugLog(message) {
            if (debugMode) {
                const timestamp = new Date().toLocaleTimeString();
                console.log(`[${timestamp}] ${message}`);
            }
        }

        function showDebugInfo() {
            debugMode = !debugMode;
            const section = document.getElementById('debugSection');
            section.style.display = debugMode ? 'block' : 'none';
            
            if (debugMode) {
                updateDebugDisplay();
            }
        }

        function updateDebugDisplay() {
            const output = document.getElementById('debugOutput');
            output.innerHTML = `
                <strong>Timeline Data:</strong> ${timelineData.length} tasks<br>
                <strong>Archive Data:</strong> ${archiveData.length} items<br>
                <strong>Learning Events:</strong> ${Object.keys(learningData).length} types<br>
                <strong>Spoon History:</strong> ${spoonHistory.length} days<br>
                <strong>Day Boundaries:</strong> ${dayStartHour}:00 - ${dayEndHour}:59<br>
                <strong>BB Emojis Used:</strong> ${bbEmojiUsed.join(', ')}<br>
                <strong>Conflicts:</strong> ${conflictWarnings.length}<br>
                <strong>Last Save:</strong> ${new Date().toLocaleTimeString()}
            `;
        }

        // ===== UI HELPERS =====
        
        function updateTimestamp() {
            const now = new Date();
            const options = { 
                weekday: 'long', 
                year: 'numeric', 
                month: 'long', 
                day: 'numeric',
                hour: '2-digit',
                minute: '2-digit',
                hour12: true,
                timeZoneName: 'short'
            };
            document.getElementById('timestamp').textContent = now.toLocaleDateString('en-US', options);
        }

        function updateLegend() {
            document.getElementById('legend').textContent = LEGEND;
        }

        function closeModal(modalId) {
            document.getElementById(modalId).style.display = 'none';
            selectedTaskIndex = null;
        }

        function selectTask(index) {
            selectedTaskIndex = index;
        }

        function resetDay() {
            if (confirm('Reset entire day? This will clear all tasks but preserve templates and archive.')) {
                timelineData = [];
                bbEmojiUsed = [];
                renderTimeline();
                saveAllData();
                debugLog('Day reset by user');
            }
        }

        function exportData() {
            const exportData = {
                timelineData,
                checkInData,
                templates,
                spoonHistory: spoonHistory.slice(-30),
                learningData,
                dayStartHour,
                dayEndHour,
                currentTimeZone,
                exportDate: new Date().toISOString(),
                version: '2.0'
            };
            
            const dataStr = JSON.stringify(exportData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            
            const link = document.createElement('a');
            link.href = url;
            link.download = `spoonpal-export-${new Date().toISOString().split('T')[0]}.json`;
            link.click();
            
            debugLog('Data exported');
        }

        function importData() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = function(e) {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        try {
                            const importedData = JSON.parse(e.target.result);
                            
                            if (confirm('Import data? This will overwrite current data.')) {
                                timelineData = importedData.timelineData || [];
                                checkInData = importedData.checkInData || {};
                                templates = importedData.templates || {};
                                spoonHistory = importedData.spoonHistory || [];
                                learningData = importedData.learningData || {};
                                dayStartHour = importedData.dayStartHour || 6;
                                dayEndHour = importedData.dayEndHour || 23;
                                currentTimeZone = importedData.currentTimeZone || 'America/Denver';
                                
                                initializeDayBoundaries();
                                validateAndSort();
                                renderTimeline();
                                autoFillCheckIn();
                                updateLearningInsights();
                                saveAllData();
                                
                                alert('Data imported successfully!');
                                debugLog('Data imported from file');
                            }
                        } catch (error) {
                            alert('Error importing data: ' + error.message);
                            debugLog('Import error: ' + error.message);
                        }
                    };
                    reader.readAsText(file);
                }
            };
            input.click();
        }

        function updateReferenceSection() {
            const referenceHTML = `
                <h4>Reference Section (System Use Only, Always Last)</h4>
                <div><strong>Legend:</strong> ${LEGEND}</div>
                <div><strong>Protocol Notes:</strong></div>
                <ul>
                    <li><strong>H comes after ME</strong> in locked LMJ order - IMMUTABLE RULE</li>
                    <li>Evening routines (N, ME, H, CC, DD, EE, FF, ZZ) cannot move ahead of G</li>
                    <li>Multiple BBs per day require unique emojis - no duplicates ever</li>
                    <li>Only one BB per day can use standard üöΩ emoji</li>
                    <li>Additional tasks slotted between B and G unless specified</li>
                    <li>Burnout advisory is guidance only - NEVER blocks scheduling</li>
                    <li>Archive instead of delete - data preservation enforced</li>
                    <li>SpoonPal learns from patterns automatically</li>
                    <li>Day boundaries configurable - defaults to 6:00-23:59</li>
                    <li>Auto-rescheduling with conflict detection enabled</li>
                    <li>Comprehensive sorting maintains LMJ and time order</li>
                </ul>
            `;
            document.getElementById('referenceSection').innerHTML = referenceHTML;
        }

        function updateNonopeLog() {
            const nonopeHTML = `
                <h4>NONOPE Log (Permanently Rejected Logic)</h4>
                <ul>
                    <li>‚è≠Ô∏è icon for Skipped status - EXPRESSLY FORBIDDEN</li>
                    <li>H before ME in timeline - violates locked LMJ order</li>
                    <li>Duplicate BB emojis in same day - uniqueness required</li>
                    <li>Task blocking during burnout - advisory only enforced</li>
                    <li>Deleting data permanently - archive system enforced</li>
                    <li>Ignoring LMJ sequence - locked order must be preserved</li>
                    <li>Midnight-only day boundaries - configurable times implemented</li>
                    <li>Manual-only task scheduling - auto-rescheduling available</li>
                    <li>Static timeline order - dynamic sorting with conflict resolution</li>
                </ul>
            `;
            document.getElementById('nonopeLog').innerHTML = nonopeHTML;
        }

        // Initialize app on page load
        window.onload = init;
    </script>
</body>
</html>
